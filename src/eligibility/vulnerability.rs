use crate::criteria::{Constraint, CriteriaSet, MetricKey, ProgramId};
use crate::eligibility::evaluator::evaluate_validator;
use crate::eligibility::{AtRiskMetric, TrendDirection, VulnerableValidator};
use crate::metrics::collector::CompetitorSnapshot;

pub fn analyze_vulnerabilities(
    program: ProgramId,
    criteria_set: &CriteriaSet,
    competitors: &[CompetitorSnapshot],
    vulnerability_margin_pct: f64,
) -> Vec<VulnerableValidator> {
    let mut out = Vec::new();
    for competitor in competitors {
        let evaluation = evaluate_validator(program, &competitor.metrics, criteria_set, None);

        let mut at_risk = Vec::new();
        for criterion in &criteria_set.criteria {
            let Some(current_value) = competitor.metrics.numeric_metric(&criterion.metric) else {
                continue;
            };
            if let Some((threshold, margin)) =
                threshold_margin(current_value, &criterion.constraint)
            {
                if margin <= vulnerability_margin_pct {
                    let trend = trend_for_metric(
                        &criterion.metric,
                        current_value,
                        competitor
                            .previous_metrics
                            .as_ref()
                            .and_then(|p| p.numeric_metric(&criterion.metric)),
                        &criterion.constraint,
                    );
                    at_risk.push(AtRiskMetric {
                        metric: criterion.metric.clone(),
                        current_value,
                        threshold,
                        margin,
                        trend,
                    });
                }
            }
        }

        if !evaluation.eligible || at_risk.is_empty() {
            continue;
        }

        out.push(VulnerableValidator {
            vote_pubkey: competitor.metrics.vote_pubkey.clone(),
            program,
            metrics_at_risk: at_risk.clone(),
            epochs_until_likely_loss: estimate_epochs_to_loss(&at_risk),
            current_delegation_sol: competitor.current_delegation_sol,
        });
    }

    out.sort_by(|a, b| {
        b.current_delegation_sol
            .total_cmp(&a.current_delegation_sol)
    });
    out
}

fn threshold_margin(current_value: f64, constraint: &Constraint) -> Option<(f64, f64)> {
    match constraint {
        Constraint::Min(threshold) => {
            if *threshold == 0.0 {
                Some((*threshold, 100.0))
            } else {
                Some((
                    *threshold,
                    ((current_value - threshold) / threshold) * 100.0,
                ))
            }
        }
        Constraint::Max(threshold) => {
            if *threshold == 0.0 {
                Some((*threshold, -100.0))
            } else {
                Some((
                    *threshold,
                    ((threshold - current_value) / threshold) * 100.0,
                ))
            }
        }
        Constraint::Range { min, max } => {
            if (*max - *min).abs() < f64::EPSILON {
                return Some((*min, -100.0));
            }
            if current_value < *min {
                let margin = ((current_value - min) / min.max(1.0)) * 100.0;
                Some((*min, margin))
            } else if current_value > *max {
                let margin = ((max - current_value) / max.max(1.0)) * 100.0;
                Some((*max, margin))
            } else {
                let nearest = (current_value - *min).min(*max - current_value);
                let denominator = (*max - *min).abs().max(1.0);
                Some((current_value, (nearest / denominator) * 100.0))
            }
        }
        _ => None,
    }
}

fn trend_for_metric(
    metric: &MetricKey,
    current: f64,
    previous: Option<f64>,
    constraint: &Constraint,
) -> TrendDirection {
    let Some(previous) = previous else {
        return TrendDirection::Stable;
    };

    let delta = current - previous;
    let worsening = match constraint {
        Constraint::Min(_) => delta < 0.0,
        Constraint::Max(_) => delta > 0.0,
        Constraint::Range { .. } => delta.abs() > 0.0,
        _ => false,
    };

    if worsening {
        TrendDirection::Deteriorating
    } else if delta.abs() < 0.001 {
        TrendDirection::Stable
    } else {
        match metric {
            MetricKey::Commission
            | MetricKey::SkipRate
            | MetricKey::MevCommission
            | MetricKey::DatacenterConcentration
            | MetricKey::StakeConcentration => {
                if delta < 0.0 {
                    TrendDirection::Improving
                } else {
                    TrendDirection::Deteriorating
                }
            }
            _ => {
                if delta > 0.0 {
                    TrendDirection::Improving
                } else {
                    TrendDirection::Deteriorating
                }
            }
        }
    }
}

fn estimate_epochs_to_loss(metrics: &[AtRiskMetric]) -> Option<u32> {
    if metrics
        .iter()
        .all(|m| !matches!(m.trend, TrendDirection::Deteriorating))
    {
        return None;
    }
    let most_urgent = metrics
        .iter()
        .map(|m| m.margin)
        .fold(f64::INFINITY, f64::min);
    if most_urgent <= 0.0 {
        Some(0)
    } else if most_urgent <= 1.0 {
        Some(1)
    } else if most_urgent <= 3.0 {
        Some(2)
    } else if most_urgent <= 5.0 {
        Some(3)
    } else {
        Some(6)
    }
}
